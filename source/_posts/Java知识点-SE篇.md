---
title: Java知识点-SE篇
tags: 信息技术
description: 知识点整理
top_img: "/img/5.png"
cover: "/img/57.jpg"
abbrlink: 9b28f329
date: 2022-08-22 12:05:56
swiper_index: 7
---
### 1.面向对象特性？
- **封装**
  利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
  优点:
  - 减少耦合: 可以独立地开发、测试、优化、使用、理解和修改
  - 减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
  - 有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能
  - 提高软件的可重用性
  - 降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的
  - **继承**
  继承实现了  **IS-A**  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。
  继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。
  - **多态**
  多态分为编译时多态和运行时多态:
  - 编译时多态主要指方法的重载
  - 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定
  运行时多态有三个条件:
  - 继承
  - 覆盖(重写)
  - 向上转型

### 2.对equals()和hashCode()的理解?
- **为什么在重写 equals 方法的时候需要重写 hashCode 方法**?
因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。
- **有没有可能两个不相等的对象有相同的 hashcode**?
有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。
- **两个相同的对象会有不同的 hash code 吗**?
不能，根据 hash code 的规定，这是不可能的。

### 3.String、StringBuffer与StringBuilder的区别？
- 第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。
- 第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。

### 4.接口与抽象类的区别？
- 一个子类只能继承一个抽象类, 但能实现多个接口
- 抽象类可以有构造方法, 接口没有构造方法
- 抽象类可以有普通成员变量, 接口没有普通成员变量
- 抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)
- 抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法
- 抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）
- 抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法

### 5.this() & super()在构造方法中的区别？
- 调用super()必须写在子类构造方法的第一行, 否则编译不通过
- super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行
- 尽管可以用this调用一个构造器, 却不能调用2个
- this和super不能出现在同一个构造器中, 否则编译不通过
- this()、super()都指的对象,不可以在static环境中使用
- 本质this指向本对象的指针。super是一个关键字

### 6.Break和continue和return有什么区别？
- break是结束循环。
- continue是跳过本次循环，执行下一次循环。
- return的作用不是结束循环，而是结束方法。

### 7.什么是方法重载（Overload）方法重写（Override）？
- 方法重载：在同一个类中，具有相同的方法名， 参数列表不同（参数的个数及类型不同），与返回值无关。
- 方法重写：在子类中出现与父类一模一样的方法，返回值类型，方法名和参数列表都相同，会出现覆盖的效果，叫做方法的重写或复写。（声明不变，重新实现）

### 8.选择排序，冒泡排序原理？
- 选择排序：用第一个元素和每一个元素进行比较，从0索引开始，依次和后面元素比较，小的放前面，第一次完毕，最小值出现在最小索引处。
- 冒泡排序：相邻元素两两比较，大的往后放，第一次比较结束，最大值出现在最大索引处。

### 9.Java中继承的特点？
- java只能单继承不能多继承但可以多层继承，即间接继承；
- 子类默认拥有父类所有的非私有成员变量及方法；
- 一个类只能有一个父类，但一个父类可以有多个子类。

### 10.继承中成员变量、成员方法如何访问？
- 子类可以直接访问父类中的非私有成员变量和方法；
- 出现同名的成员变量或方法时，在子类要访问父类的非私有成员变量或方法需要用 super引用；
- 构造方法不会被继承，子类初始化对象数据时一定会先调用父类的无参构造。

### 11.多态的好处和弊端（如何解决）？
- 好处：提高程序的扩展性，有更好的维护性（增加新子类不影响已存在类的多态性、继承性及其他操作）
- 弊端：不能使用子类特有的成员。
- 解决弊端：向下转型。

### 12.静态代码块的特点？
- 给类变量（静态变量）进行初始化赋值
- 随着类的加载而执行且只执行一次，并且优先级高于main方法和构造方法。

### 13.静态成员变量和成员变量的区别？
- 所属不同。静态成员变量属于类，成员变量属于对象。
- 内存位置不同。静态成员变量存在于静态区，成员变量存在于堆内存。
- 内存出现时间不同。静态成员变量随着类的加载而加载，且只加载一次，成员变量随对象的创建而存在。
- 调用不同。静态成员变量可以被类和对象调用，成员变量只能被对象调用。

### 14.多态的前提？
- 要有继承或实现关系
- 要有方法的重写
- 要有父类引用指向子类对象

### 15.throws和throw的区别？
- throw代表抛出一个异常的动作，throws代表可能有异常抛出的一种状态。
- throw用在方法实现中，throws用在方法声明中。
- throw只能用于抛出一种异常，throws可以抛出多个异常。

### 16.Finally有什么特点？
- 在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。
- finally不能单独使用。必须配合着try...catch使用。
- 如果catch中有return语句，先执行finally中的代码，再执行return语句。

### 17.List集合有什么特点？List有3个子类，特点？
- 有序可重复
- ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高。
- LinkedList：底层数据结构是链表，查询慢，增删快，线程不安全，效率高。
- Vector：底层数据结构是数组，查询快，增删慢，线程安全，效率低。

### 18.数组和集合有什么区别？
- 数组长度固定，集合长度可变。
- 数组存储同一类型的元素，可以存储基本数据类型值。
- 集合存储的是对象，类型可以不一致，不能存放基本数据类型。

### 19.Final finally，finalize区别？
- final:是修饰符，修饰类，类不能被继承；修饰变量，不能被重新赋值，变成常量；修饰方法，方法不能被重写。
- finally:是异常处理的一部分，用于释放资源。finally中的代码一定会被执行，特殊情况，在执行finally之前jvm退出。
- finalize:是object类的一个方法，用于垃圾回收。

### 20.HashSet如何保证数据唯一性？
- 通过hashCode()和equals()方法
- 先看hashCode()值是否相同
- 相同：继续equals()方法，
返回true：元素重复，不添加；
返回false：元素不重复，添加
- 不同：直接添加

### 21.hashMap和hashTable的区别？
- hashMap：线程不安全，效率高，允许null键和null值。
- hashTable：线程安全，效率低，不允许null键和null值。

### 22.Collection 和 collections有什么区别？
- collection是一个集合接口，提供了对集合对象进行基本操作的通用接口方法，collection接口在Java类库中有很多具体的体现，意义是为各种具体的集合提供了最大化的统一操作方式。
- collections是一个操作集合的工具类，包含各种有关集合操作的静态多态方法，不能实例化，服务于Java的collection框架。

### 23.什么是递归？写递归要注意什么？
- 递归是在自己的方法内调用自己。
- 递归一定要有条件限制，保证递归能够停止，否则会发生栈内存溢出。
- 递归次数不能太多，否则也会发生栈内存溢出。
- 构造方法禁止递归，构造方法是创建对象使用的，不能让对象一直创建下去。

### 24.== 和 eques的区别？
- ==是运算符，如果是基本数据类型，比较存储的值，如果是引用数据类型，比较所指对象的地址值（是否为同一个类）。
- equals是object的方法，比较所指对象的地址值，重写之后比较对象的值。

### 25.IO流中的flush和close有什么区别？
- close();关闭流对象，但是先刷新一次缓冲区，关闭之后，流对象不可以继续使用。
- flush();仅仅刷新缓冲区，刷新之后，流对象还可以继续使用。

### 26.Thread类和runable接口有什么区别？
- Runnable接口可以避免单继承的局限性，具有较强的健壮性。
- Runnable可以实现资源的共享，同时处理同一资源。
- Thread类的线程间都是独立运行的，资源不共享。
- 继承Thread类不再被其他类继承（Java不存在多继承）

### 27.什么是线程安全？如何判断一个程序是否会出现线程安全呢？
- 多线程执行的结果和单线程运行的结果一样，就是线程安全的。
- 是否有共享资源   是
- 是否有多条执行路径   是
- 是否这多条路径操作共享资源   是